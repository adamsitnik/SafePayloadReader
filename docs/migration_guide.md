# Binary Formatter migration guide

## General Overview

* `BinaryFormatter` by default serializes **all fields** that are not marked with `[NonSerialized]` attribute. For auto-properties, it uses names generated by the compiler. It can be customized by implementing  `GetObjectData` method from `ISerializable` interface, but requires to implement a serialization constructor that accepts `SerializationInfo info` and `StreamingContext context` arguments.
* `PayloadReader` should be used for reading pre-existing payload that was serialized with `BinaryFormatter` and persisted.


## Table of Contents

## How does Binary Formatter work?

The `BinaryFormatter` was first introduced with the initial release of the .NET Framework in 2002. It's very likely that engineers who are assigned to the migration task may not have the necessary knowledge or experience to work with the `BinaryFormatter`. This can lead to errors, delays, or failures.
Therefore, it is crucial for engineers to understand how the old technology works before they start the migration. 

`BinaryFormatter` can serialize any `object` that is annotated with `[Serializable]` attribute or implements `ISerializable` interface.

### Member names

In most common scenario the type is just annotated with `[Serializable]` attribute and the serializer uses reflection to serialize **all fields** that are not annotated with `[NonSerialized]` attribute. In case of C# auto properties, they are backed by fields generated by the C# compiler so the names of the serialized fields are compiler-generated (and not very human friendly to say politely).

Let's use one of the C# decompilers like [https://sharplab.io/](https://sharplab.io/) or [ILSpy](https://github.com/icsharpcode/ILSpy) to see what field gets generated for following simple property.

```cs
[Serializable]
public class PropertySample
{
    public string Name { get; set; }
}
```

Is translated by the C# compiler to:

```cs
[Serializable]
public class PropertySample
{
    private string <Name>k__BackingField;

    public string Name
    {
        get
        {
            return <Name>k__BackingField;
        }
        set
        {
            <Name>k__BackingField = value;
        }
    }
}
```

And in this particular case `<Name>k__BackingField` is the name of the member that `BinaryFormatter` uses in the serialized payload. It's impossible to use `nameof` or any other C# operator to get this name.

[ISerializable](https://learn.microsoft.com/dotnet/api/system.runtime.serialization.iserializable) interface comes with [GetObjectData(SerializationInfo info, StreamingContext context)](https://learn.microsoft.com/dotnet/api/system.runtime.serialization.iserializable.getobjectdata) method that allows the users to control the names, by using one of the [SerializationInfo.AddValue](https://learn.microsoft.com/dotnet/api/system.runtime.serialization.serializationinfo.addvalue) methods.


```cs
public void GetObjectData(SerializationInfo info, StreamingContext context)
{
    info.AddValue("Name", this.Name);
}
```

If such customization has been applied, the information needs to be provided during deserialization as well. It's possible by using the **serialization constructor** where all values are read from `SerializationInfo` by using one of the `Get` methods it provides.


```cs
private PropertySample(SerializationInfo info, StreamingContext context)
{
    this.Name = info.GetString("Name");
}
```

**Note:** The `nameof` operator was not used here on purpose, as the payload can be persisted and the property can get renamed at some point of time. So even if it gets renamed (let's say to `FirstName` because we decided to also introduce `LastName` property), to remain backward compatibility the serialization should still use the old name that could have been persisted somewhere.

### Serialization Binder

On top of that, it's recommended to use [SerializationBinder](https://learn.microsoft.com/dotnet/api/system.runtime.serialization.serializationbinder) to control class loading and mandate what class to load and therefore minimize security vulnerabilities (so only allowed types get loaded, even if the attacker modifies the payload to deserialize and load something else).

Using this type requires inheriting from it and overriding the [Type BindToType(string assemblyName, string typeName)](https://learn.microsoft.com/dotnet/api/system.runtime.serialization.serializationbinder.bindtotype#system-runtime-serialization-serializationbinder-bindtotype(system-string-system-string)) method.

If given codebase uses custom type that derives from `SerializationBinder` it's likely that the list of serializable types is a **closed set**. If not, finding the list of all types that can get serialized and deserialized is going to require studying all the usages of `BinaryFormatter` in source code. **Knowing that list is crucial to determining how to move further with the migration**.

## Reading persisted payload

**Do you own any data that was serialized with `BinaryFormatter` and persisted**? Sample scenarios that typically don't include persisting the payload:
- Deep object cloning (allocate a stream, serialize to it, seek to the begining of the stream, deserialize from it and return deserialized instance).
- Testing whether given type is serializable.

A scenario where it depends is inter-process communication. If you own all the processes and can migrate them at the same time, you don't need to read the payload. However, if you own only one side (example: you expose a backend that accepts requests from 3rd party clients), or you can not shut down all the processes to perform the migration, you need to read it.

**If you don't need to read the payload, you can skip this paragraph**. If you do, you are going to need to use `PayloadReader`.

`PayloadReader` can read any payload that was serialized with `BinaryFormatter` (except of types specific to **remoting** which were never ported to .NET (Core)). However, it's mostly useful only when the list of serialized types is a known, closed set. Or put it otherwise, you need to know up front what you want to read, because at the end of the day you also need to create instances of these types and populate them with data that was read from the payload. Let's consider two opposite examples.

All `[Serializable]` types from [Quartz.NET](https://github.com/search?q=repo%3Aquartznet%2Fquartznet+%5BSerializable%5D+language%3AC%23&type=code&l=C%23) that can be persisted by the library itself are `sealed`, so there are no custom types that the users could create and the payload can contain only known types. They also provide public constructors, so it is possible to re-create these types based on the information read from payload.

`SettingsPropertyValue` from `System.Configuration.ConfigurationManager` library exposes an `object PropertyValue` that may use `BinaryFormatter` to serialize and deserialize any object that was stored in the configuration file. It could be used to store an integer, a custom type, a dictionary or literally anything.  Because of that, **it is impossible to migrate this library (in a secure manner), as the payload can contain anything**.

For now we can simplify the process and assume that for the time of migration from `BinaryFormatter`, the app should do the following:

- Check if the payload read from storage is a binary formatter payload.
- If so, read it with `PayloadReader`, serialize back with a new serializer and overwrite the data in the storage.
- If not, use the new serializer to deserialize the data.

To check whether given buffer or stream contains binary formatter payload, you need to call `PayloadReader.ContainsBinaryFormatterPayload` method.

// TODO: use simpler example

```cs
ClassRecord rootObject = PayloadReader.ReadAnyClassRecord(payload);

if (rootObject.IsTypeNameMatching(typeof(CronExpression)))
{
    string cronExpression;
    int timeZoneId;
    int version = rootObject.GetInt32("version");
    if (version == 0)
    {
        cronExpression = rootObject.GetString("cronExpressionString");
        timeZoneId = rootObject.GetClassRecord("timeZone").GetInt32("Id");
    }
    else if (version == 1)
    {
        cronExpression = rootObject.GetString("cronExpression");
        timeZoneId = rootObject.GetInt32("timeZoneId");
    }

    return new CronExpression(cronExpression)
    {
        TimeZone = TimeZoneUtil.FindTimeZoneById(timeZoneId)
    };
}
else if (rootObject.IsTypeNameMatching(typeof(TimeOfDay)))
{
    return new TimeOfDay(
        rootObject.GetInt32("Hour"),
        rootObject.GetInt32("Minute"),
        rootObject.GetInt32("Second"),
    )
}


```

## Usage scenarios

To be able to migrate away from it, it's required to understand how and why it's being used.

- Is the payload being stored anywhere?
  - Yes. Example: serialize, store in a file and deserialize later. We need to use `PayloadReader` to read pre-existing payload.
  - No. Example: Deep object cloning, IPC, `[Serializable]` testing.
- Is the list of types that are being deserialized a closed set?
  - Yes. It's possible to use `PayloadReader`.
  - No. 
- Who owns the types that being serialized? Can they be extended?
  - Yes. We can recommend any serializer that requires applying some attributes on the type.
  - No. We can recommend only the serializers that support the concept of converters.
- Is compact binary representation important?
  - Yes. Example: user cares about payload size, we can't recommend any MS serializer.
  - No. It's most likely the ease of use and we can use XML or JSON serializer.






## Alternatives

## Summary



