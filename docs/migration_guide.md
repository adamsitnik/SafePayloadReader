# Binary Formatter migration guide

* [General Overview](#general-overview)
* [How does Binary Formatter work?](#how-does-binary-formatter-work)
    + [Member names](#member-names)
    + [Serialization Binder](#serialization-binder)
* [Reading binary format payload in secure way](#reading-binary-format-payload-in-secure-way)
* [Choosing different serializer](#choosing-different-serializer)
    + [JSON](#json)
    + [XML](#xml)
    + [Binary serializers](#binary-serializers)
        - [MessagePack](#messagepack)
        - [Bond](#bond)
* [BF forever aka OOB package](#bf-forever-aka-oob-package)

## General Overview

* `BinaryFormatter` by default serializes **all fields** that are not marked with `[NonSerialized]` attribute. For auto-properties, it uses names generated by the compiler. It can be customized by implementing  `GetObjectData` method from `ISerializable` interface, but requires to implement a serialization constructor that accepts `SerializationInfo info` and `StreamingContext context` arguments. It also preserves the references and handles circular references.
* `PayloadReader` should be used for reading any `BinaryFormatter` payload that was either persisted before the migration or comes from a service that can not be migrated (example: owned by a 3rd party).
* `PayloadReader` can read any Binary Format payload, but it's mandatory to know the list of types that could have been serialized. Otherwise, it's impossible to create and hydrate the serialized objects.
* Is compact binary representation important for your scenario? If so, you need to switch to a different binary serializer. If not, you can consider using JSON and XML serializers.
* [System.Text.Json](https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/overview) is strict by default and avoids any guessing or interpretation on the caller's behalf, emphasizing deterministic behavior. The library is intentionally designed this way for performance and security. In contrary to `BinaryFormatter`, by default it serializes **only public properties**. To deserialize a `readonly` field or property, `[JsonConstructor]` attribute needs be used to indicate that given constructor should be used to set these. It supports serialization and deserialization of most built-in collections, but it does not support dictionaries where keys are not primitive types. It supports polymorphic type hierarchy serialization and deserialization, but it needs to be explicitly enabled. The same goes for preserving the references and handling circular references. The default behavior can be changed by writing custom converters.
* [MessagePack](https://github.com/MessagePack-CSharp/MessagePack-CSharp) provides a **highly efficient binary serialization format**, resulting in smaller message sizes compared to JSON and XML. It's **very performant** and ships with built-in support for LZ4 compression. It **supports only public types**, and it works best when all serializable types and members are annotated with dedicated attributes. It does not serialize non-public members by default, but it can be customized. It supports readonly types and members, by trying to select the best matching constructor. The constructor can be selected in an explicit way by using the `[SerializationConstructor]` attribute.


## Table of Contents

## How does Binary Formatter work?

The `BinaryFormatter` was first introduced with the initial release of the .NET Framework in 2002. It's very likely that engineers who are assigned to the migration task may not have the necessary knowledge or experience to work with the `BinaryFormatter`. This can lead to errors, delays, or failures.
Therefore, it is crucial for engineers to understand how the old technology works before they start the migration. 

`BinaryFormatter` can serialize any `object` that is annotated with `[Serializable]` attribute or implements `ISerializable` interface.

### Member names

In most common scenario the type is just annotated with `[Serializable]` attribute and the serializer uses reflection to serialize **all fields** that are not annotated with `[NonSerialized]` attribute. In case of C# auto properties, they are backed by fields generated by the C# compiler, so the names of the serialized fields are compiler-generated (and not very human friendly to say politely).

Let's use one of the C# decompilers like [https://sharplab.io/](https://sharplab.io/) or [ILSpy](https://github.com/icsharpcode/ILSpy) to see what field gets generated for following simple property.

```cs
[Serializable]
public class PropertySample
{
    public string Name { get; set; }
}
```

Is translated by the C# compiler to:

```cs
[Serializable]
public class PropertySample
{
    private string <Name>k__BackingField;

    public string Name
    {
        get
        {
            return <Name>k__BackingField;
        }
        set
        {
            <Name>k__BackingField = value;
        }
    }
}
```

And in this case `<Name>k__BackingField` is the name of the member that `BinaryFormatter` uses in the serialized payload. It's impossible to use `nameof` or any other C# operator to get this name.

[ISerializable](https://learn.microsoft.com/dotnet/api/system.runtime.serialization.iserializable) interface comes with [GetObjectData(SerializationInfo info, StreamingContext context)](https://learn.microsoft.com/dotnet/api/system.runtime.serialization.iserializable.getobjectdata) method that allows the users to control the names, by using one of the [SerializationInfo.AddValue](https://learn.microsoft.com/dotnet/api/system.runtime.serialization.serializationinfo.addvalue) methods.


```cs
public void GetObjectData(SerializationInfo info, StreamingContext context)
{
    info.AddValue("Name", this.Name);
}
```

If such customization has been applied, the information needs to be provided during deserialization as well. It's possible by using the **serialization constructor** where all values are read from `SerializationInfo` by using one of the `Get` methods it provides.


```cs
private PropertySample(SerializationInfo info, StreamingContext context)
{
    this.Name = info.GetString("Name");
}
```

**Note:** The `nameof` operator was not used here on purpose, as the payload can be persisted and the property can get renamed at some point of time. So even if it gets renamed (let's say to `FirstName` because we decided to also introduce `LastName` property), to remain backward compatibility the serialization should still use the old name that could have been persisted somewhere.

### Serialization Binder

On top of that, it's recommended to use [SerializationBinder](https://learn.microsoft.com/dotnet/api/system.runtime.serialization.serializationbinder) to control class loading and mandate what class to load and therefore minimize security vulnerabilities (so only allowed types get loaded, even if the attacker modifies the payload to deserialize and load something else).

Using this type requires inheriting from it and overriding the [Type BindToType(string assemblyName, string typeName)](https://learn.microsoft.com/dotnet/api/system.runtime.serialization.serializationbinder.bindtotype#system-runtime-serialization-serializationbinder-bindtotype(system-string-system-string)) method.

If given codebase uses custom type that derives from `SerializationBinder` it's likely that the list of serializable types is a **closed set**. If not, finding the list of all types that can get serialized and deserialized is going to require studying all the usages of `BinaryFormatter` in source code. **Knowing that list is crucial to determining how to move further with the migration**.

## Reading binary format payload in secure way

**Do you own any data that was serialized with `BinaryFormatter` and persisted**? Sample scenarios that typically don't include persisting the payload:
- Deep object cloning (allocate a stream, serialize to it, seek to the beginning of the stream, deserialize from it and return deserialized instance).
- Testing whether given type is serializable.

A scenario where it depends, is inter-process communication. If you own all the processes and can migrate them at the same time, you don't need to read the binary format payload. However, if you own only one side (example: you expose a backend that accepts requests from 3rd party clients), or you can not shut down all the processes to perform the migration, you need to read it.

**If you don't need to read the payload, you can skip this paragraph**. If you do, you are going to need to use `PayloadReader`.

`PayloadReader` can read any payload that was serialized with `BinaryFormatter` (except of types specific to **remoting** which were never ported to .NET (Core)). However, it's mostly useful only when the list of serialized types is a known, closed set. Or put it otherwise, you need to know up front what you want to read, because at the end of the day you also need to create instances of these types and populate them with data that was read from the payload. Let's consider two opposite examples.

All `[Serializable]` types from [Quartz.NET](https://github.com/search?q=repo%3Aquartznet%2Fquartznet+%5BSerializable%5D+language%3AC%23&type=code&l=C%23) that can be persisted by the library itself are `sealed`, so there are no custom types that the users could create and the payload can contain only known types. They also provide public constructors, so it is possible to re-create these types based on the information read from payload.

`SettingsPropertyValue` from `System.Configuration.ConfigurationManager` library exposes an `object PropertyValue` that may use `BinaryFormatter` to serialize and deserialize any object that was stored in the configuration file. It could be used to store an integer, a custom type, a dictionary or literally anything.  Because of that, **it is impossible to migrate this library (in a secure manner), as the payload can contain anything**.

For now, we can simplify the process and assume that for the time of migration from `BinaryFormatter`, the app should do the following:

- Check if the payload read from storage is a binary formatter payload.
- If so, read it with `PayloadReader`, serialize back with a new serializer (choosing new serializer is explained later in this document) and overwrite the data in the storage.
- If not, use the new serializer to deserialize the data.

To check whether a given buffer or stream contains binary formatter payload, you need to call `PayloadReader.ContainsBinaryFormatterPayload` method.

TODO: just copy-paste the README.md of PayloadReader here once it's finished

```cs
[Serializable]
public class Sample
{
    public int Integer;
    public string? Text;
    public byte[]? ArrayOfBytes;
    public Sample? ClassInstance;
}

ClassRecord rootRecord = PayloadReader.ReadExactClassRecord<Sample>(payload);
Sample output = new()
{
    // using the dedicated methods to read primitive values
    Integer = rootRecord.GetInt32(nameof(Sample.Integer)),
    Text = rootRecord.GetString(nameof(Sample.Text)),
    // using dedicated method to read an array of bytes
    ArrayOfBytes = rootRecord.GetArrayOfPrimitiveType<byte>(nameof(Sample.ArrayOfBytes)),
    // using GetClassRecord to read a class record
    ClassInstance = new()
    {
        Text = rootRecord
            .GetClassRecord(nameof(Sample.ClassInstance))!
            .GetString(nameof(Sample.Text))
    }  
};
```

## Choosing different serializer

Choosing different serializer boils down to two questions:

- Is compact binary representation important for your scenario? If so, you need to switch to a different binary serializer. If not, you can consider using JSON and XML serializers.
- Can you modify the types that are being serialized by annotating them with attributes, adding new constructors, making the types public and changing fields to properties? If not, using the modern serializers might require a lot of workarounds.

TODO: Add a table similar to https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/reflection-vs-source-generation?pivots=dotnet-8-0#feature-comparison with a comparison of:
- Supported TFMs (they may support the same TFMs so maybe this won't be required and some space can be saved)
- fields vs properties
- private vs public
- readonly handling
- polymorphic type hierarchy serialization and deserialization


### JSON

[System.Text.Json](https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/overview) is strict by default and avoids any guessing or interpretation on the caller's behalf, emphasizing deterministic behavior. The library is intentionally designed this way for performance and security. From the migration perspective, it's crucial to know the following facts:
- By default, **fields aren't serialized**, but they can be [included on demand](https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/fields), which is a must-have for types that use fields that are not exposed by properties. The simplest solution that does not require modifying the types is to use the global setting to include fields.
```cs
JsonSerializerOptions options = new()
{
    IncludeFields = true
};
```
- By default, System.Text.Json **ignores private fields and properties**. You can enable use of a non-public accessor on a property by using the `[JsonInclude]` attribute. Including private fields requires some [non-trivial extra work](https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/custom-contracts#example-serialize-private-fields).
- It **[can not deserialize readonly fields](https://learn.microsoft.com/dotnet/api/system.text.json.jsonserializeroptions.ignorereadonlyfields?view#remarks)** or properties, but `[JsonConstructor]` attribute can be used to indicate that given constructor should be used to create instances of the type on deserialization. And obviously the constructor can set the readonly fields and properties.
- It [supports serialization and deserialization of most built-in collections](https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/supported-collection-types). The exceptions:
    - multi-dimensional arrays,
    - `BitArray`,
    - `LinkedList<T>`.
    - `Dictionary<TKey, TValue>`, where `TKey` is not a primitive type,
    - `BlockingCollection<T>` and `ConcurrentBag<T>`,
    - most of the collections from [System.Collections.Specialized](https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/supported-collection-types#systemcollectionsspecialized-namespace) and [System.Collections.ObjectModel](https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/supported-collection-types#systemcollectionsobjectmodel-namespace) namespaces.
- Under [certain condtions](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/supported-collection-types#custom-collections-with-deserialization-support), it supports serialization and deserialization of custom generic collections.
- Other types [without built-in support](https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/migrate-from-newtonsoft?pivots=dotnet-9-0#types-without-built-in-support) are: `DataSet`, `DataTable`, `DBNull`, `TimeZoneInfo`, `Type`, `ValueTuple`. However, you can write a custom converter to support these types. 
- It [supports polymorphic type hierarchy serialization and deserialization](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/polymorphism) that have been explicitly opted in via the `[JsonDerivedType]` attribute or via custom resolver.
- The `[JsonIgnore]` attribute on a property causes the property to be omitted from the JSON during serialization.
- To preserve references and handle circular references in System.Text.Json, set `JsonSerializerOptions.ReferenceHandler` to `Preserve`.
- To override the default behavior you can [write custom converters](https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/converters-how-to).

### XML

### Binary serializers

#### MessagePack

MessagePack provides a highly efficient binary serialization format, resulting in smaller message sizes compared to JSON and XML. It's very [performant](https://github.com/MessagePack-CSharp/MessagePack-CSharp?tab=readme-ov-file#performance) and ships with built-in support for LZ4 compression.

MessagePack provides a compact binary size and a full set of general purpose expressive data types.

- **Only public types are supported!**
- By default, MessagePack requires each serializable type to be annotated with `[MessagePackObject]` attribute. It's possible to avoid that by using the [ContractlessStandardResolver](https://github.com/MessagePack-CSharp/MessagePack-CSharp?tab=readme-ov-file#object-serialization), but it may cause issues with versioning in the future.
- Every serializable non-static field and a property needs to be annotated with `[Key]` attribute. If you annotate the type with `[MessagePackObject(keyAsPropertyName: true)]` attribute, then members do not require explicit annotations. In such case, to ignore certain public members the `[IgnoreMember]` attribute needs to be used.
- To serialize private members, use [DynamicObjectResolverAllowPrivate](https://github.com/MessagePack-CSharp/MessagePack-CSharp?tab=readme-ov-file#object-serialization).
- `System.Runtime.Serialization` annotations can be used instead of MessagePack annotations. `[DataContract]` instead of`[MessagePackObject]`, `[DataMember]` instead of `[Key]` and `[IgnoreDataMember]` instead of `[IgnoreMember]`. It can be very useful if you want to avoid having dependency on MessagePack in the library that defines serializable types. (TODO: try to port Quartz by using these annotations).
- It supports readonly/immutable types and members. The serializer will try to use the public constructor with the best matched argument list. It can be specified in an explicit way by using `[SerializationConstructor]` attribute.
- The serializer supports most frequently used built-in types and collections provided by the .NET base class libraries. You can find the full list in [official docs](https://github.com/MessagePack-CSharp/MessagePack-CSharp?tab=readme-ov-file#built-in-supported-types). It has [extension points](https://github.com/MessagePack-CSharp/MessagePack-CSharp?tab=readme-ov-file#extensions) that allow for customization.
- The library provides [Typless API](https://github.com/MessagePack-CSharp/MessagePack-CSharp?tab=readme-ov-file#typeless) similar to `BinaryFormatter`, but it should not be used as it's not [secure](https://github.com/MessagePack-CSharp/MessagePack-CSharp?tab=readme-ov-file#security) and would defeat the purpose of migrating from `BinaryFormatter`.


#### Bond

## BF forever aka OOB package